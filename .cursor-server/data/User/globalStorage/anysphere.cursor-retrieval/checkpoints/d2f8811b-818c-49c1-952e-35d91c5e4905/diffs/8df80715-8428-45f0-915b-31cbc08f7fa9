{"fsPath":"/root/itsbot/main_fast.py","fileUuid":"8df80715-8428-45f0-915b-31cbc08f7fa9","fileSizeBytes":8158,"numLines":230,"diffChanges":[{"originalStartLineNumberOneIndexed":1,"originalEndLineNumberExclusiveOneIndexed":1,"modifiedStartLineNumberOneIndexed":1,"modifiedEndLineNumberExclusiveOneIndexed":231,"addedLines":["# OPTIMIZED VERSION - Run with python3 main_fast.py --offset N","# Speed optimizations: async requests, concurrent attempts, pre-warmed connections, faster timeouts","import datetime","import asyncio","import aiohttp","import argparse","import time","","URL = \"https://www.itstheseason.christmas/api/advent/claim\"","","# Wallet addresses","WALLETS: list[str] = [","    \"0xFfbdC115f419ABeD23888812f00D10F12EF6DA3e\",","    \"0x61bc0dBf7f960679124FF9Be26C7617ca10BfEeB\",","    \"0x55322A6A9ec077a20C9352a75274975e09Ce7f75\",","    \"0x7529fcdb6f71b13e262dae0ede0d7c9aca5a554c\",","    \"\",  \"\",  \"\",  \"\",  \"\",  \"\",","    \"\",  \"\",  \"\",  \"\",  \"\",  \"\",","    \"\",  \"\",  \"\",  \"\",  \"\",  \"\",","    \"\",  \"\",","]","","HEADERS = {","    \"accept\": \"*/*\",","    \"accept-encoding\": \"gzip, deflate, br\",","    \"content-type\": \"application/json\",","    \"origin\": \"https://www.itstheseason.christmas\",","    \"referer\": \"https://www.itstheseason.christmas/\",","    \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36\",","}","","# Speed optimizations","BURST_ATTEMPTS = 10  # Number of concurrent attempts during burst","TIMEOUT = 2.0  # Reduced timeout for faster failure recovery","CONNECTOR_LIMIT = 20  # Connection pool size","","","def in_burst_window(now_utc: datetime.datetime) -> bool:","    \"\"\"More aggressive burst window for FCFS\"\"\"","    m = now_utc.minute","    s = now_utc.second","    ms = now_utc.microsecond","    ","    # Start earlier at 59:58 to catch early openings","    if m == 59 and s >= 58:","        return True","    # Extended window up to 00:10 for retries","    if m == 0 and s <= 10:","        return True","    return False","","","def in_prepare_window(now_utc: datetime.datetime) -> bool:","    \"\"\"Earlier prep window for connection warming\"\"\"","    return (now_utc.minute == 59 and 50 <= now_utc.second <= 57)","","","def get_submit_hour(now_utc: datetime.datetime) -> int:","    h = now_utc.hour","    if now_utc.minute == 59:","        return (h + 1) % 24","    return h","","","async def log_request(log_file: str, ts_utc: datetime.datetime, hour: int, wallet: str, status: int, body: str, error: str = \"\"):","    \"\"\"Async logging to not block main loop\"\"\"","    line = (","        f\"{ts_utc.isoformat()}Z\\t\"","        f\"hour={hour}\\t\"","        f\"wallet={wallet}\\t\"","        f\"status={status}\\t\"","    )","    if error:","        line += f\"error={error}\\n\"","    else:","        short = body.replace(\"\\n\", \" \")","        if len(short) > 500:","            short = short[:500] + \"...(truncated)\"","        line += f\"body={short}\\n\"","    ","    # Non-blocking file write","    loop = asyncio.get_event_loop()","    await loop.run_in_executor(None, _write_log, log_file, line)","","","def _write_log(log_file: str, line: str):","    \"\"\"Sync log writer for executor\"\"\"","    with open(log_file, \"a\", encoding=\"utf-8\") as f:","        f.write(line)","","","async def send_claim_request(session: aiohttp.ClientSession, wallet: str, hour: int, log_file: str, attempt: int):","    \"\"\"Send a single claim request\"\"\"","    payload = {","        \"walletAddress\": wallet,","        \"hour\": hour,","    }","    ","    now_utc = datetime.datetime.utcnow()","    try:","        async with session.post(","            URL,","            json=payload,","            headers=HEADERS,","            timeout=aiohttp.ClientTimeout(total=TIMEOUT),","            ssl=False  # Skip SSL verification for speed (use with caution)","        ) as resp:","            body_str = await resp.text()","            await log_request(log_file, now_utc, hour, wallet, resp.status, body_str)","            ","            # Return success status","            if resp.status == 200 and \"Successfully claimed\" in body_str:","                return True, body_str","            return False, body_str","            ","    except asyncio.TimeoutError:","        await log_request(log_file, now_utc, hour, wallet, -1, \"\", error=f\"Timeout (attempt {attempt})\")","        return False, \"timeout\"","    except Exception as e:","        await log_request(log_file, now_utc, hour, wallet, -1, \"\", error=f\"{str(e)} (attempt {attempt})\")","        return False, str(e)","","","async def burst_attack(session: aiohttp.ClientSession, wallet: str, hour: int, log_file: str):","    \"\"\"Send multiple concurrent requests for FCFS advantage\"\"\"","    tasks = []","    for i in range(BURST_ATTEMPTS):","        task = asyncio.create_task(send_claim_request(session, wallet, hour, log_file, i+1))","        tasks.append(task)","        # Stagger launches slightly (microseconds) for better timing spread","        if i < BURST_ATTEMPTS - 1:","            await asyncio.sleep(0.001)  # 1ms delay between launches","    ","    # Wait for all attempts","    results = await asyncio.gather(*tasks, return_exceptions=True)","    ","    # Check if any succeeded","    for success, body in results:","        if isinstance(success, bool) and success:","            print(f\"âœ“ Successfully claimed hour {hour} for {wallet[:10]}...\")","            return True","    ","    return False","","","async def warm_connection(session: aiohttp.ClientSession):","    \"\"\"Pre-warm the connection with DNS resolution and TCP handshake\"\"\"","    try:","        async with session.get(","            \"https://www.itstheseason.christmas/\",","            headers=HEADERS,","            timeout=aiohttp.ClientTimeout(total=3),","            ssl=False","        ):","            pass","    except Exception:","        pass","","","async def main(wallet_offset: int):","    \"\"\"Main async loop with speed optimizations\"\"\"","    log_file = f\"advent_log_fast_{wallet_offset}.txt\"","    ","    # Optimized connector with connection pooling and keep-alive","    connector = aiohttp.TCPConnector(","        limit=CONNECTOR_LIMIT,","        limit_per_host=CONNECTOR_LIMIT,","        ttl_dns_cache=300,  # DNS cache for 5 minutes","        force_close=False,  # Keep connections alive","        enable_cleanup_closed=True","    )","    ","    # Create persistent session","    async with aiohttp.ClientSession(connector=connector) as session:","        warmed_up_for_this_hour = None","        last_burst_hour = None","        ","        print(f\"ðŸš€ Fast bot started with offset {wallet_offset}\")","        print(f\"ðŸ“ Logging to {log_file}\")","        ","        while True:","            now_utc = datetime.datetime.utcnow()","            utc_minute = now_utc.minute","            utc_second = now_utc.second","            utc_hour = now_utc.hour","            ","            # (1) Connection warming - start earlier","            if in_prepare_window(now_utc):","                if warmed_up_for_this_hour != utc_hour:","                    print(f\"ðŸ”¥ Warming up connections for hour {utc_hour}...\")","                    # Warm multiple times for better connection state","                    await asyncio.gather(","                        warm_connection(session),","                        warm_connection(session),","                        warm_connection(session)","                    )","                    warmed_up_for_this_hour = utc_hour","            ","            # (2) Burst attack window","            if in_burst_window(now_utc):","                submit_hour = get_submit_hour(now_utc) + 1","                ","                # Only attack once per hour to avoid spam","                if last_burst_hour != submit_hour:","                    wallet_index = (get_submit_hour(now_utc) + wallet_offset) % 24","                    wallet = WALLETS[wallet_index]","                    ","                    if wallet:  # Only if wallet is configured","                        print(f\"âš¡ BURST ATTACK: Hour {submit_hour}, Wallet {wallet[:10]}..., Time: {utc_minute}:{utc_second:02d}\")","                        success = await burst_attack(session, wallet, submit_hour, log_file)","                        if success:","                            last_burst_hour = submit_hour","                    ","                # Very short sleep during burst window","                await asyncio.sleep(0.05)  # 50ms","                continue","            ","            # (3) Minimal sleep during waiting period","            await asyncio.sleep(0.1)  # 100ms for responsiveness","","","if __name__ == \"__main__\":","    parser = argparse.ArgumentParser(description=\"Optimized FCFS claim bot\")","    parser.add_argument(\"--offset\", type=int, default=0, help=\"wallet index offset (default: 0)\")","    args = parser.parse_args()","    ","    # Run the async main loop","    asyncio.run(main(args.offset))","",""],"tokenizedAddedLines":[1000000,1000001,1000002,1000003,1000004,1000005,1000006,1000007,1000008,1000007,1000009,1000010,1000011,1000012,1000013,1000014,1000015,1000015,1000015,1000016,1000017,1000007,1000018,1000019,1000020,1000021,1000022,1000023,1000024,1000025,1000007,1000026,1000027,1000028,1000029,1000007,1000007,1000030,1000031,1000032,1000033,1000034,1000035,1000036,1000037,1000038,1000039,1000040,1000038,1000041,1000007,1000007,1000042,1000043,1000044,1000007,1000007,1000045,1000046,1000047,1000048,1000049,1000007,1000007,1000050,1000051,1000052,1000053,1000054,1000055,1000056,1000057,1000058,1000059,1000060,1000061,1000062,1000063,1000064,1000035,1000065,1000066,1000067,1000007,1000007,1000068,1000069,1000070,1000071,1000007,1000007,1000072,1000073,1000074,1000075,1000076,1000077,1000035,1000078,1000079,1000080,1000081,1000082,1000083,1000084,1000085,1000086,1000087,1000088,1000089,1000090,1000091,1000092,1000093,1000089,1000094,1000095,1000096,1000097,1000098,1000099,1000007,1000007,1000100,1000101,1000102,1000103,1000104,1000105,1000106,1000107,1000108,1000035,1000109,1000110,1000035,1000111,1000112,1000113,1000114,1000115,1000035,1000041,1000007,1000007,1000116,1000117,1000079,1000118,1000119,1000083,1000120,1000121,1000122,1000123,1000124,1000125,1000007,1000007,1000126,1000127,1000128,1000035,1000129,1000130,1000131,1000132,1000133,1000134,1000135,1000057,1000035,1000136,1000137,1000138,1000139,1000140,1000141,1000142,1000140,1000143,1000144,1000145,1000146,1000147,1000089,1000148,1000149,1000150,1000151,1000152,1000153,1000154,1000154,1000155,1000156,1000157,1000089,1000158,1000159,1000160,1000161,1000162,1000163,1000164,1000165,1000166,1000167,1000168,1000169,1000170,1000171,1000166,1000172,1000173,1000174,1000089,1000175,1000176,1000007,1000007,1000177,1000178,1000179,1000180,1000035,1000181,1000182,1000007,1000007]}],"gitInfo":{"noRepoFound":true},"kind":"KIND_ADDED"}